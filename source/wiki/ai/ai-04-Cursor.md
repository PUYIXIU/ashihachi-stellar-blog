---
wiki: ai # 项目id
title: Cursor
---

# 文档

## 核心


### 核心：智能体

- 模式
  - Agent
  - Ask
  - Manual
  - 创建自定义模式
- 工具
  - 开启：Auto-Run Mode
  - Agent可以使用工具来搜索、编辑、运行命令
  - 工具比如：Git、终端、资源文件操作、MCP Tools
- 聊天标签页：
  - 快捷键：Ctrl+T
- 检查点 CheckPoint
  - 自动快照跟踪Agent更改，可以进行restore恢复
- 终端集成
  - 可以使用Agent执行终端命令、监控输出并处理多步骤流程
  - 为可信工作流配置自动运行
- 聊天历史
  - 快捷键：Alt+Ctrl+‘
  - 回顾之前讨论、跟踪编码会话、参考早期聊天上下文
- 导出聊天（应该会经常用到）
  - 导出为markdown格式
  - 与团队成员分享解决方案、或从编码会话中创建知识库
- 规则
  - 可以使用rules，为Agent的行为定义自定义指令
  - 有助于维护编码标准、强制执行模式、个性化Agent

#### 智能体：聊天

- 标签页
  - Ctrl+T 创建新的标签页
  - Ctrl+Tab 切换标签页
  - 每个标签页的对话历史、上下文、模型选择独立
  - 建议：每个标签页使用一个任务，提供清晰的初始描述，并关闭已完成的标签页以保持工作区整洁（和分支开发很像呢）
  - 冲突：多个标签页编辑相同的文件时，系统会提示解决冲突（和git merge很像呢）
  - 引用其他聊天记录：使用Past Chats来包含其他标签页或者之前绘画的上下文
- CheckPoint 检查点
  - 用途：在Agent更改后保存和恢复之前的状态
  - 提示：检查点不是版本控制，还是需要使用git来保存永久历史记录
  - 工作原理：
    - 本地存储
    - 仅跟踪Agent更改
    - 自动清理（在当前会话和最近的历史记录中保存）
- 导出
  - 导出内容
    - 所有消息和响应
    - 语法高亮代码块
    - 文件引用和上下文
    - 按时间顺序的对话流程
    - 注意：导出时请检查敏感数据：API密钥、内部URL、专有代码、个人信息等
- 复制
  - 从对话中的任意点创建分支
  - 选择 Duplicate Chat
  - 关于复制的对话：
    - 到该时间点的上下文会被保留
    - 原始对话保持不变
    - 两个聊天都维护各自独立的历史记录
- 历史记录
  - 历史聊天记录可以打开、删除、重命名
  - 记录会存储在本机器SQLite数据库中
  - 后台代理：不在常规的历史记录中，而是存储在远程数据库中
    - 查看快捷键：Ctrl+E
  - 引用过往聊天记录：@Past Chats
- 摘要功能
  - 聊天中长对话的上下文管理
  - Cursor会自动摘要和管理上下文，保持聊天的高效
    - 上下文工作原理：https://docs.cursor.com/zh/guides/working-with-context
  - 原理简述：
    - 当对话变得越来越长时，Cursor会对比较旧的消息进行摘要（压缩）
    - 对文件和文件夹，Cursor使用另一种处理方式：智能压缩
      - Cursor会根据文件大小和可用上下文空间确定呈现它们的最佳方式
    - 文件压缩的几种情况：
      - 已压缩
        - 压缩会向模型显示关键的结构元素，如函数签名、类、方法。
        - 模型有需要时展开特定文件
        - 最大化了对可用上下文窗口的有效利用
      - 显著压缩
        - 文件太大而无法完整包含，压缩也不行，模型只能获取到文件名
      - 未包含（警告）
        - 项目太大无法包含在上下文窗口

#### 智能体：规划

- Agent如何通过规划和管理复杂任务
  - 提前规划
  - 结构化的待办事项列表、消息队列
- Agent待办事项
  - 将较长的任务分解为可管理的步骤
  - 建立依赖关系？
  - 结构化计划会随工作进展而更新
- 工作原理（这一步真的很像git分支管理）
  - 自动为复杂任务创建待办事项列表
  - 每个项目都可以依赖于其他任务
  - 列表随工作进展实时更新
  - 已完成的任务会自动标记为完成
- 可见性
  - 方式1：显示在聊天界面中
  - 方式2：Slack集成显示？
    - https://docs.cursor.com/zh/slack
  - 注意：最好清楚地描述最终目标，让Agent了解完整范围，才能创建更准确的任务分解
- 使用队列
  - 当Agent正在工作时，输入下一个指令
  - Enter将其添加到队列中
  - 消息按顺序显示在活动任务下方
  - 点击箭头可以重新排列队列消息
  - Agent会在完成后按顺序处理它们
  - 覆盖队列：强制推送消息，会绕过队列立即执行
    - Alt+Enter


#### 智能体：模式

- Agent
  - 自主探索、多文件编辑、启用所有工具
  - 
- Ask
  - 只读探索、无自动更改、仅搜索工具
- Manual
  - 直接文件编辑、具有明确控制、仅编辑工具
  - 只编辑明确选择的文件
  - 在确切知道要编辑什么时效果最佳，选择正确的文件并给出清晰的指令
- Custom
  - 用户定义的功能
  - 对特定的工具组合和指令创建自定义模式

#### 智能体：工具

- 在Custom模式下，智能体的这些工具可以被自由的启用/禁用
- 搜索-Search（搜索代码库/网络以查找相关信息）
  - 读取文件-Read files（最多250行，最大模式下为750行）
  - 列出目录-List directory（只读取目录结构，不读取文件内容）
  - 代码库-Codebase（在已索引代码库中执行语义搜索）
  - Grep（在文件中搜索确切的关键词或模式）
  - 搜索文件-Search files（使用模糊匹配按名称查找文件）
  - 网络-Web（生成搜索查询并执行网络搜索）
  - 获取规则-Fetch rules（根据类型和描述检索特定的规则）
- 编辑-Edit（对文件和代码库进行特定编辑）
  - 编辑和重新应用-Edit & Reapply（文件编辑并自动应用）
  - 删除文件-Delete file
- 运行-Run（与终端进行交互）
  - 终端-Terminal（运行终端命令并监控输出）
    - Cursor使用默认的终端配置文件
    - 修改终端配置文件：
      - Ctrl+Shift+P
      - Terminal:Select Default Profile
- MCP
  - 可以使用配置的MCP服务器与外部服务进行交互，例如数据库或第三方API
- 高级选项
  - 自动应用编辑Auto-apply edits
    - 自动应用编辑无需手动确认
  - 自动运行Auto-run
    - 自动执行终端命令并接受编辑
    - 适用于运行测试套件和验证更改（修改后自动更新包）
  - 安全防护
    - 一大堆允许配置，来确保哪些工具可以自动执行
  - 自动修复错误
    - 当Agent遇到代码检查错误和警告时自动解决

#### 智能体：Apply

- Apply：应用、接受或拒绝聊天中的代码建议
- 原理：
  - Apply是一个专门的Cursor模型
  - 专门接收Agent生成的代码，并集成到文件中（类似快递员？）
  - Apply不生成代码（只是代码的搬运工，误），只负责集成
  - 可以处理多个文件和大型代码库的更改

#### 智能体：差异对比与审查

- 审查和管理由AI代理生成的代码更改（和git merge类似）
- 逐文件审查
- 选择性接受
- 审查更改（review changes）查看更改的完整差异


### 核心：后台代理 Background Agent

- 目前没有用到，有需要再看文档
https://docs.cursor.com/zh/background-agent


### 核心：Web & Mobile

- 目前没有用到，有需要再看文档
  https://docs.cursor.com/zh/background-agent/web-and-mobile#slack




### 核心：规则

- 通过可重用的作用域指令控制Agent模型的行为
  - 可以视为项目的持久上下文、偏好设置或工作流程
- 规则适用范围：为Agent和内联编辑提供系统级指令（tab不适用）
- 支持类型：
  - 项目规则
    - 存储在.cursor/rules中
    - 受版本控制作用于代码库
    - 可以使用路径模式进行规则限定/手动调用/基于相关性包含
    - 嵌套规则：
      - 子目录可以包含自己的.cursor/rules目录，范围限定在该文件夹内
      - 嵌套规则会根据项目层级自动附加
    - 可以使用项目规则来：
      - 编码关于代码库的领域特定知识
      - 自动化项目特定的工作流程或模版
      - 标准化样式或架构决策？
  - 用户规则
    - 全局应用于Cursor环境
    - 设置中定义并始终生效
    - 比较适合设置首选的沟通风格或编码约定
- 原理：
  - 规则在提示级别提供持久的、可重用的上下文
  - 应用时，规则内容会包含在模型上下文的开始部分
- 规则结构
  - MDC编写，支持元数据和内容格式
  - 规则应用方式：
    - 属性：
      - description 规则描述
      - globs 作用域
      - alwaysApply 应用范围
    - 范围：
      - Always 始终包含在模型上下文中
      - Auto Attached 引用匹配glob模式的文件时包含
      - Agent Requested 由AI决定是否包含，因此必须提供描述
      - Manual 仅在使用@ruleName显式提及时包含
- 创建规则
  - 创建方式1：Cursor Settings > Rules 可以看到并管理所有规则
  - 创建方式2：New Cursor Rule命令
  - 创建方式3：/Generate Cursor Rules命令
    - 根据当前和智能体的对话，生成规则
- 建议
  - 规则应该是专注的、可操作的、有明确范围的（和人一样）
  - 保持规则在500行以内
  - 将大型规则拆分为多个可组合的规则
  - 提供具体的实例或引用文件（乐，怎么跟人一样）
  - 避免模糊指导，编写规则时要像清晰的内部文档一样
  - 在聊天中重复提示时重用规则

这里Cursor文档里提供了几个规则标准，还挺有意思的：https://docs.cursor.com/zh/context/rules#cursor
还有更多示例可以从提供商、框架、社区贡献的在线众包集合和储存库中找到

```mdc
---
alwaysApply: true
globs:
description: 自动化开发工作流程和文档生成
---
此规则自动化应用分析：
当被要求分析应用时：
1. 使用 npm run dev 运行开发服务器
2. 从控制台获取日志
3. 建议性能改进
此规则帮助生成文档：
通过以下方式帮助起草文档：
- 提取代码注释
- 分析README.md
- 生成markdown文档
```


### 核心：记忆

- 记忆如何创建
  - Sidecar观察
    - 有一个独立的模型，观察对话并自动提取记忆
    - 在后台被动进行
    - 后台生成的记忆需要用户批准才能保存，确保对内容的信任和控制
  - 工具调用
    - 当用户明确要求Agent记住某些内容
    - 或当它注意到应该为未来的会话保留重要信息时
    - Agent可以直接使用工具调用创建记忆
- 管理记忆
  - Cursor Setting > Rules 中管理记忆

## 上下文

### 上下文：代码库索引

- 通过为每个文件计算嵌入向量来索引代码库
  - 如果已索引代码库6周不活跃后会被删除
- 检查索引状态：Cursor Setting > Indexing & Docs
- 配置
  - 忽略文件（.gitignore、.cursorignore）
    - 提示：忽略大型内容文件可以提高答案准确性
  - 查看已索引文件：View included files，
- 多根工作区
  - 所有代码库都会自动建立索引
  - AI可用每个代码库的上下文
  - .cursor/rules在所有文件夹中都有效
- PR搜索
  - 通过让历史变更可搜索和通过AI访问，帮助立即代码库的演进过程
  - 原理：
    - 自动索引所有已合并的PR，来自仓库记录
    - 摘要会出现在语义搜索结果中
    - 通过智能过滤来优先显示最近的变更
    - Agent可以使用@获取PR、提交、问题或分支到上下文中
      - @[PR 编号]
      - @[commit hash]
      - @[branch name]
  - 支持平台有限，目前主要是github和bitbucket

### 上下文：忽略文件

- 配置文件：
  - .cursorignore
  - .cursirindexingignore
    - 仅从索引中排除文件，文件可以被AI访问，但不会出现在代码库搜索中
- 阻止范围：
  - index
  - tab、agent、inline edit
  - @
- 注意：Agent发起的工具调用（终端/MCP）无法阻止
- 为什么要忽略
  - 性能：排除无关部分可以实现更快的索引，和更准确的文件发现
  - 安全性：
    - 限制对API密钥、凭据、机密信息的访问
    - 虽然可以限制访问，但由于LLM的不可预测性，无法保证完全保护？？？
- 全局忽略文件
  - Settings > Global Cursor Ignore List
- 配置.cursorignore
  - 在根目录中使用.gitignore语法创建.cursorignore文件
- 默认忽略文件
  - .gitignore中的文件
  - 一些默认忽略列表（文档里有）
  - 在.cursorignore中可以使用!前缀覆盖
- 否定模式限制
  - 以!为前缀
  - 如果父目录通过*被排除，则无法重新包含文件（好微妙。。。）
  - 建议：显式排除嵌套目录


### 上下文：MCP
https://modelcontextprotocol.io/docs/getting-started/intro

- MCP（Model Context Protocol）
- MCP使Cursor能够连接到外部工具和数据源
  - 无需重复解释项目结构，直接与工具集成
- 工作原理：
  - MCP服务器通过协议公开功能，将Cursor连接到外部工具或数据源
  - 支持三种传输方式：
    - stdio
      - Cursor管理/单用户/shell命令/手动
    - SSE
      - 部署为服务器/多用户/SSE端点URL/OAuth
    - Streamable HTTP
      - 部署为服务器/多用户/HTTP端点URL/OAuth

ps：感觉功能挺牛掰的，需要花时间结合实践看

https://docs.cursor.com/zh/context/mcp

### 上下文：@符号


- @Files 引用特定文件
- @Folders 引用整个文件夹
- @Code 引用特定代码片段或符号
- @Docs 访问文档和指南
- @Git 访问git历史记录和更改
- @Past Chats 使用汇总的编辑器回话
- @Rules 使用cursor规则
- @Terminals 终端
- @Active Tabs 激活的智能体
- @Linter Errors 引用lint错误
- @Web 外部网络资源和文档
- @Link 粘贴URL时，Cursor会将其自动标记为@Link，支持PDF
- @Recent Changes 创建指向特定代码或文档的联机
- #Files 将文件添加到上下文中而不引用
- /Commands 将打开和活动的文件添加到上下文中

